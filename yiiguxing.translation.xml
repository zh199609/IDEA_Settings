<application>
  <component name="AppStorage">
    <histories>
      <item value="Constructs an UnsupportedOperationException with the specified detail message. Params: message – the detail message" />
      <item value="Constructs a FileWriter object given a file name with a boolean indicating whether or not to append the data written. Params: fileName – String The system-dependent filename. append – boolean if true, then data will be written to the end of the file rather than the beginning. Throws: IOException – if the named file exists but is a directory rather than a regular file, does not exist but cannot be created, or cannot be opened for any other reason" />
      <item value="Returns the current time in milliseconds. Note that while the unit of time of the return value is a millisecond, the granularity of the value depends on the underlying operating system and may be larger. For example, many operating systems measure time in units of tens of milliseconds. See the description of the class Date for a discussion of slight discrepancies that may arise between &quot;computer time&quot; and coordinated universal time (UTC). Returns: the difference, measured in milliseconds, between the current time and midnight, January 1, 1970 UTC. See Also: java.util.Date" />
      <item value="NamingException while looking up DataSource: Need to specify class name in environment or system property, or as an applet parameter, or in an application resource file: java.naming.factory.initial" />
      <item value="Splits this string around matches of the given regular expression. This method works as if by invoking the two-argument split method with the given expression and a limit argument of zero. Trailing empty strings are therefore not included in the resulting array. The string &quot;boo:and:foo&quot;, for example, yields the following results with these expressions: Regex Result : { &quot;boo&quot;, &quot;and&quot;, &quot;foo&quot; } o { &quot;b&quot;, &quot;&quot;, &quot;:and:f&quot; } Params: regex – the delimiting regular expression Returns: the array of strings computed by splitting this string around matches of the given regular expression Throws: PatternSyntaxException – if the regular expression's syntax is invalid Since: 1.4 See Also: Patter" />
      <item value="Split a String at the first occurrence of the delimiter. Does not include the delimiter in the result. Params: toSplit – the string to split delimiter – to split the string up with Returns: a two element array with index 0 being before the delimiter, and index 1 being after the delimiter (neither element includes the delimiter); or null if the delimiter wasn't found in the given input String" />
      <item value="Inserts the string into this character sequence. The characters of the String argument are inserted, in order, into this sequence at the indicated offset, moving up any characters originally above that position and increasing the length of this sequence by the length of the argument. If str is null, then the four characters &quot;null&quot; are inserted into this sequence. The character at index k in the new character sequence is equal to: the character at index k in the old character sequence, if k is less than offset the character at index k-offset in the argument str, if k is not less than offset but is less than offset+str.length() the character at index k-str.length() in the old character sequence, if k is not less than offset+str.length() The offset argument must be greater than or equal to 0, and less than or equal to the length of this sequence. Params: offset – the offset. str – a string. Returns: a reference to this object. Throws: StringIndexOutOfBoundsException – if the offset is invalid" />
      <item value="Returns a BigInteger whose value is (this val). Params: val – value by which this BigInteger is to be divided. Returns: this val Throws: ArithmeticException – if val is zero." />
      <item value="Upper Ell" />
      <item value="A constant holding the maximum value an int can have" />
      <item value="Need to specify class name in environment or system property, or as an applet parameter" />
      <item value="escape" />
      <item value="was expecting double-quote to start field name" />
      <item value="The ORDER BY clause is invalid in views, inline functions, derived tables, subqueries, and common table expressions, unless TOP, OFFSET or FOR XML is also specified.; nested exception is com.microsoft.sqlserver.jdbc.SQLServerException: The ORDER BY clause is invalid in views, inline functions, derived tables, subqueries, and common table expressions, unless TOP, OFFSET or FOR XML is also specified." />
      <item value="The ORDER BY clause is invalid in views, inline functions, derived tables, subqueries, and common table expressions, unless TOP, OFFSET or FOR XML is also specified." />
      <item value="Encountered unexpected token" />
      <item value="found for dependency: expected at least 1 bean which qualifies as autowire candidate for this dependency" />
      <item value="Whether body content is required. Default is true, leading to an exception thrown in case there is no body content. Switch this to false if you prefer null to be passed when the body content is null." />
      <item value="Returns a function that always returns its input argument. Type parameters: &lt;T&gt; – the type of the input and output objects to the function Returns: a function that always returns its input argument" />
      <item value="Performs a mutable reduction operation on the elements of this stream using a Collector. A Collector encapsulates the functions used as arguments to collect(Supplier, BiConsumer, BiConsumer), allowing for reuse of collection strategies and composition of collect operations such as multiple-level grouping or partitioning. If the stream is parallel, and the Collector is concurrent, and either the stream is unordered or the collector is unordered, then a concurrent reduction will be performed (see Collector for details on concurrent reduction.) This is a terminal operation. When executed in parallel, multiple intermediate results may be instantiated, populated, and merged so as to maintain isolation of mutable data structures. Therefore, even when executed in parallel with non-thread-safe data structures (such as ArrayList), no additional synchronization is needed for a parallel reduction." />
      <item value="Simple stop watch, allowing for timing of a number of tasks, exposing total running time and running time for each named task. Conceals use of System.currentTimeMillis(), improving the readability of application code and reducing the likelihood of calculation errors. Note that this object is not designed to be thread-safe and does not use synchronization. This class is normally used to verify performance during proof-of-concepts and in development, rather than as part of production applications. Since: May 2, 2001 Author: Rod Johnson, Juergen Hoeller, Sam Brannen" />
      <item value="Essence" />
      <item value="Failed to execute goal org.apache.maven.plugins:maven-surefire-plugin:2.16:test (default-test) on project CCForum: Execution default-test of goal org.apache.maven.plugins:maven-surefire-plugin:2.16:test failed: Fork count always is not a legal value" />
      <item value="The parameter forkMode is deprecated since version 2.14. Use forkCount and reuseForks instead." />
      <item value="The main pool control state, ctl, is an atomic integer packing two conceptual fields workerCount, indicating the effective number of threads runState, indicating whether running, shutting down etc In order to pack them into one int, we limit workerCount to (2^29)-1 (about 500 million) threads rather than (2^31)-1 (2 billion) otherwise representable. If this is ever an issue in the future, the variable can be changed to be an AtomicLong, and the shiftmask constants below adjusted. But until the need arises, this code is a bit faster and simpler using an int. The workerCount is the number of workers that have been permitted to start and not permitted to stop. The value may be transiently different from the actual number of live threads, for example when a ThreadFactory fails to create a thread when asked, and when exiting threads are still performing bookkeeping before terminating. The user-visible pool size is reported as the current size of the workers set. The runState provides the main lifecycle control, taking on values: RUNNING: Accept new tasks and process queued tasks SHUTDOWN: Don't accept new tasks, but process queued tasks STOP: Don't accept new tasks, don't process queued tasks, and interrupt in-progress tasks TIDYING: All tasks have terminated, workerCount is zero, the thread transitioning to state TIDYING will run the terminated() hook method TERMINATED: terminated() has completed The numerical order among these values matters, to allow ordered comparisons. The runState monotonically increases over time, but need not hit each state. The transitions are: RUNNING -&gt; SHUTDOWN On invocation of shutdown(), perhaps implicitly in finalize() (RUNNING or SHUTDOWN) -&gt; STOP On invocation of shutdownNow() SHUTDOWN -&gt; TIDYING When both queue and pool are empty STOP -&gt; TIDYING When pool is empty TIDYING -&gt; TERMINATED When the terminated() hook method has completed Threads waiting in awaitTermination() will return when the state reaches TERMINATED. Detecting the transition from SHUTDOWN to TIDYING is less straightforward than you'd like because the queue may become empty after non-empty and vice versa during SHUTDOWN state, but we can only terminate if, after seeing that it is empty, we see that workerCount is 0 (which sometimes entails a recheck -- see below)." />
      <item value="Execute the given task. The call might return immediately if the implementation uses an asynchronous execution strategy, or might block in the case of synchronous execution. Params: task – the Runnable to execute (never null) Throws: TaskRejectedException – if the given task was not accepted" />
      <item value="Simple task executor interface that abstracts the execution of a Runnable. Implementations can use all sorts of different execution strategies, such as: synchronous, asynchronous, using a thread pool, and more. Equivalent to JDK 1.5's Executor interface; extending it now in Spring 3.0, so that clients may declare a dependency on an Executor and receive any TaskExecutor implementation. This interface remains separate from the standard Executor interface mainly for backwards compatibility with JDK 1.4 in Spring 2.x." />
      <item value="The multi-part identifier" />
      <item value="Conversion" />
      <item value="Criteria" />
      <item value="FETCH" />
      <item value="OFFSET" />
      <item value="Returns a view of the portion of this list between the specified fromIndex, inclusive, and toIndex, exclusive. (If fromIndex and toIndex are equal, the returned list is empty.) The returned list is backed by this list, so non-structural changes in the returned list are reflected in this list, and vice-versa. The returned list supports all of the optional list operations supported by this list. This method eliminates the need for explicit range operations (of the sort that commonly exist for arrays). Any operation that expects a list can be used as a range operation by passing a subList view instead of a whole list. For example, the following idiom removes a range of elements from a list: list.subList(from, to).clear(); Similar idioms may be constructed for indexOf and lastIndexOf, and all of the algorithms in the Collections class can be applied to a subList. The semantics of the list returned by this method become undefined if the backing list (i.e., this list) is structurally modified in any way other than via the returned list. (Structural modifications are those that change the size of this list, or otherwise perturb it in such a fashion that iterations in progress may yield incorrect results.) Params: fromIndex – low endpoint (inclusive) of the subList toIndex – high endpoint (exclusive) of the subList Returns: a view of the specified range within this list" />
      <item value="Returns true if the specified object is equal to this enum constant. Params: other – the object to be compared for equality with this object. Returns: true if the specified object is equal to this enum constant." />
      <item value="Serial Number" />
      <item value="IDENTITY INSERT" />
      <item value="criteria" />
      <item value="placeholder" />
      <item value="Invoice Process" />
      <item value="DBAppender cannot function if the JDBC driver does not support getGeneratedKeys method and without a specific SQL dialect" />
      <item value="violations" />
      <item value="release Config Service" />
    </histories>
    <option name="languageScores">
      <map>
        <entry key="CHINESE" value="42" />
        <entry key="ENGLISH" value="43" />
      </map>
    </option>
  </component>
  <component name="Cache">
    <option name="lastTrimTime" value="1636955650654" />
  </component>
</application>