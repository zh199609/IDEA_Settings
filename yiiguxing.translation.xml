<application>
  <component name="AppStorage">
    <histories>
      <item value="Returns a BigInteger whose value is (this val). Params: val – value by which this BigInteger is to be divided. Returns: this val Throws: ArithmeticException – if val is zero." />
      <item value="Upper Ell" />
      <item value="A constant holding the maximum value an int can have" />
      <item value="Need to specify class name in environment or system property, or as an applet parameter" />
      <item value="escape" />
      <item value="was expecting double-quote to start field name" />
      <item value="The ORDER BY clause is invalid in views, inline functions, derived tables, subqueries, and common table expressions, unless TOP, OFFSET or FOR XML is also specified.; nested exception is com.microsoft.sqlserver.jdbc.SQLServerException: The ORDER BY clause is invalid in views, inline functions, derived tables, subqueries, and common table expressions, unless TOP, OFFSET or FOR XML is also specified." />
      <item value="The ORDER BY clause is invalid in views, inline functions, derived tables, subqueries, and common table expressions, unless TOP, OFFSET or FOR XML is also specified." />
      <item value="Encountered unexpected token" />
      <item value="found for dependency: expected at least 1 bean which qualifies as autowire candidate for this dependency" />
      <item value="Whether body content is required. Default is true, leading to an exception thrown in case there is no body content. Switch this to false if you prefer null to be passed when the body content is null." />
      <item value="Returns a function that always returns its input argument. Type parameters: &lt;T&gt; – the type of the input and output objects to the function Returns: a function that always returns its input argument" />
      <item value="Performs a mutable reduction operation on the elements of this stream using a Collector. A Collector encapsulates the functions used as arguments to collect(Supplier, BiConsumer, BiConsumer), allowing for reuse of collection strategies and composition of collect operations such as multiple-level grouping or partitioning. If the stream is parallel, and the Collector is concurrent, and either the stream is unordered or the collector is unordered, then a concurrent reduction will be performed (see Collector for details on concurrent reduction.) This is a terminal operation. When executed in parallel, multiple intermediate results may be instantiated, populated, and merged so as to maintain isolation of mutable data structures. Therefore, even when executed in parallel with non-thread-safe data structures (such as ArrayList), no additional synchronization is needed for a parallel reduction." />
      <item value="Simple stop watch, allowing for timing of a number of tasks, exposing total running time and running time for each named task. Conceals use of System.currentTimeMillis(), improving the readability of application code and reducing the likelihood of calculation errors. Note that this object is not designed to be thread-safe and does not use synchronization. This class is normally used to verify performance during proof-of-concepts and in development, rather than as part of production applications. Since: May 2, 2001 Author: Rod Johnson, Juergen Hoeller, Sam Brannen" />
      <item value="Essence" />
      <item value="Failed to execute goal org.apache.maven.plugins:maven-surefire-plugin:2.16:test (default-test) on project CCForum: Execution default-test of goal org.apache.maven.plugins:maven-surefire-plugin:2.16:test failed: Fork count always is not a legal value" />
      <item value="The parameter forkMode is deprecated since version 2.14. Use forkCount and reuseForks instead." />
      <item value="The main pool control state, ctl, is an atomic integer packing two conceptual fields workerCount, indicating the effective number of threads runState, indicating whether running, shutting down etc In order to pack them into one int, we limit workerCount to (2^29)-1 (about 500 million) threads rather than (2^31)-1 (2 billion) otherwise representable. If this is ever an issue in the future, the variable can be changed to be an AtomicLong, and the shiftmask constants below adjusted. But until the need arises, this code is a bit faster and simpler using an int. The workerCount is the number of workers that have been permitted to start and not permitted to stop. The value may be transiently different from the actual number of live threads, for example when a ThreadFactory fails to create a thread when asked, and when exiting threads are still performing bookkeeping before terminating. The user-visible pool size is reported as the current size of the workers set. The runState provides the main lifecycle control, taking on values: RUNNING: Accept new tasks and process queued tasks SHUTDOWN: Don't accept new tasks, but process queued tasks STOP: Don't accept new tasks, don't process queued tasks, and interrupt in-progress tasks TIDYING: All tasks have terminated, workerCount is zero, the thread transitioning to state TIDYING will run the terminated() hook method TERMINATED: terminated() has completed The numerical order among these values matters, to allow ordered comparisons. The runState monotonically increases over time, but need not hit each state. The transitions are: RUNNING -&gt; SHUTDOWN On invocation of shutdown(), perhaps implicitly in finalize() (RUNNING or SHUTDOWN) -&gt; STOP On invocation of shutdownNow() SHUTDOWN -&gt; TIDYING When both queue and pool are empty STOP -&gt; TIDYING When pool is empty TIDYING -&gt; TERMINATED When the terminated() hook method has completed Threads waiting in awaitTermination() will return when the state reaches TERMINATED. Detecting the transition from SHUTDOWN to TIDYING is less straightforward than you'd like because the queue may become empty after non-empty and vice versa during SHUTDOWN state, but we can only terminate if, after seeing that it is empty, we see that workerCount is 0 (which sometimes entails a recheck -- see below)." />
      <item value="Execute the given task. The call might return immediately if the implementation uses an asynchronous execution strategy, or might block in the case of synchronous execution. Params: task – the Runnable to execute (never null) Throws: TaskRejectedException – if the given task was not accepted" />
      <item value="Simple task executor interface that abstracts the execution of a Runnable. Implementations can use all sorts of different execution strategies, such as: synchronous, asynchronous, using a thread pool, and more. Equivalent to JDK 1.5's Executor interface; extending it now in Spring 3.0, so that clients may declare a dependency on an Executor and receive any TaskExecutor implementation. This interface remains separate from the standard Executor interface mainly for backwards compatibility with JDK 1.4 in Spring 2.x." />
      <item value="The multi-part identifier" />
      <item value="Conversion" />
      <item value="Criteria" />
      <item value="FETCH" />
      <item value="OFFSET" />
      <item value="Returns a view of the portion of this list between the specified fromIndex, inclusive, and toIndex, exclusive. (If fromIndex and toIndex are equal, the returned list is empty.) The returned list is backed by this list, so non-structural changes in the returned list are reflected in this list, and vice-versa. The returned list supports all of the optional list operations supported by this list. This method eliminates the need for explicit range operations (of the sort that commonly exist for arrays). Any operation that expects a list can be used as a range operation by passing a subList view instead of a whole list. For example, the following idiom removes a range of elements from a list: list.subList(from, to).clear(); Similar idioms may be constructed for indexOf and lastIndexOf, and all of the algorithms in the Collections class can be applied to a subList. The semantics of the list returned by this method become undefined if the backing list (i.e., this list) is structurally modified in any way other than via the returned list. (Structural modifications are those that change the size of this list, or otherwise perturb it in such a fashion that iterations in progress may yield incorrect results.) Params: fromIndex – low endpoint (inclusive) of the subList toIndex – high endpoint (exclusive) of the subList Returns: a view of the specified range within this list" />
      <item value="Returns true if the specified object is equal to this enum constant. Params: other – the object to be compared for equality with this object. Returns: true if the specified object is equal to this enum constant." />
      <item value="Serial Number" />
      <item value="IDENTITY INSERT" />
      <item value="criteria" />
      <item value="placeholder" />
      <item value="Invoice Process" />
      <item value="DBAppender cannot function if the JDBC driver does not support getGeneratedKeys method and without a specific SQL dialect" />
      <item value="violations" />
      <item value="release Config Service" />
    </histories>
    <option name="languageScores">
      <map>
        <entry key="CHINESE" value="35" />
        <entry key="ENGLISH" value="36" />
      </map>
    </option>
  </component>
  <component name="Cache">
    <option name="lastTrimTime" value="1636955650654" />
  </component>
</application>